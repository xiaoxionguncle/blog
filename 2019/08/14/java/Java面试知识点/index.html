<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>LeoneZhu‘s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="String 在Java中String类为什么要设计成finnal？ ​    https://blog.csdn.net/u013905744/article/details/52414111   集合多线程 什么是多线程？与单线程的区别？有什么好处？ 答题思路：先描述什么进程？什么是线程？什么是多线程？然后再描述多线程的优缺点。最后结合实际使用 答：进程是程序的一次动态执行过程。线程是比进程更">
<meta property="og:type" content="article">
<meta property="og:title" content="LeoneZhu‘s Blog">
<meta property="og:url" content="https://leonezhu.github.io/blog/2019/08/14/java/Java面试知识点/index.html">
<meta property="og:site_name" content="LeoneZhu‘s Blog">
<meta property="og:description" content="String 在Java中String类为什么要设计成finnal？ ​    https://blog.csdn.net/u013905744/article/details/52414111   集合多线程 什么是多线程？与单线程的区别？有什么好处？ 答题思路：先描述什么进程？什么是线程？什么是多线程？然后再描述多线程的优缺点。最后结合实际使用 答：进程是程序的一次动态执行过程。线程是比进程更">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-09T03:22:50.281Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoneZhu‘s Blog">
<meta name="twitter:description" content="String 在Java中String类为什么要设计成finnal？ ​    https://blog.csdn.net/u013905744/article/details/52414111   集合多线程 什么是多线程？与单线程的区别？有什么好处？ 答题思路：先描述什么进程？什么是线程？什么是多线程？然后再描述多线程的优缺点。最后结合实际使用 答：进程是程序的一次动态执行过程。线程是比进程更">
  
    <link rel="alternate" href="/blog/atom.xml" title="LeoneZhu‘s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">LeoneZhu‘s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">记录美丽生活</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://leonezhu.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java/Java面试知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/08/14/java/Java面试知识点/" class="article-date">
  <time datetime="2019-08-13T18:31:42.657Z" itemprop="datePublished">2019-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li><p>在Java中String类为什么要设计成finnal？</p>
<p>​    <a href="https://blog.csdn.net/u013905744/article/details/52414111" target="_blank" rel="noopener">https://blog.csdn.net/u013905744/article/details/52414111</a></p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>什么是多线程？与单线程的区别？有什么好处？</p>
<p>答题思路：先描述什么进程？什么是线程？什么是多线程？然后再描述多线程的优缺点。最后结合实际使用</p>
<p>答：进程是程序的一次动态执行过程。线程是比进程更小的执行单位，执行流。多线程就是值程序中包含多个执行流，就是说一个程序中可以同时运行多个线程来并向执行不同的任务。</p>
<p>多线程的好处：可以提高CPU利用率，在多线程程序中，一个线程必须等待的时候（逻辑处理，耗时）。CPU可以运行其他的线程而不是等待，这样提高了效率，也就是程序运行速度。</p>
<p>多线程的不利：</p>
<ul>
<li>线程也是程序，需要占用内存，线程越多占用内存也越多。</li>
<li>多线程需要协调和管理，所以需要CPU时间跟踪线程； </li>
<li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题；</li>
<li>线程太多会导致控制太复杂，最终可能造成很多Bug；</li>
</ul>
<p>比如获取商品详情页数据的接口时，需要返回商品的图片信息、规格、相似商品等，这里就用了CountDownLatch这个多线程计数器来实现多线程</p>
</li>
<li><p>Thead.start()实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">       /**</span><br><span class="line">        * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">        * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">        * to this method in the future may have to also be added to the VM.</span><br><span class="line">        *</span><br><span class="line">        * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">        */</span><br><span class="line">        //1 判断线程状态，是否</span><br><span class="line">       if (threadStatus != 0)</span><br><span class="line">           throw new IllegalThreadStateException();</span><br><span class="line">  </span><br><span class="line">       /* Notify the group that this thread is about to be started</span><br><span class="line">        * so that it can be added to the group&apos;s list of threads</span><br><span class="line">        * and the group&apos;s unstarted count can be decremented. */</span><br><span class="line">       group.add(this);</span><br><span class="line">  </span><br><span class="line">       boolean started = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = true;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(this);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Throwable ignore) &#123;</span><br><span class="line">               /* do nothing. If start0 threw a Throwable then</span><br><span class="line">                 it will be passed up the call stack */</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/5b09274af265da0de25759d5" target="_blank" rel="noopener">https://juejin.im/post/5b09274af265da0de25759d5</a></p>
</li>
<li><p>Java中线程的实现方式</p>
<p>1.实现Runnable。2继承Thread类。Thread类也是Runnable的子类，但是Thread类并没有完全实现Runnable接口中的run()方法，Thread类中的run()方法调用的是Runnable接口中的run()方法，也就是说该方法是由Runnable子类完成的，所以要通过继承Thread类实现多线程，则必须覆写run()方法。</p>
<p><strong>两种方式的区别是实现Runnable接口可以避免单继承的局限性，二是可以实现资源的共享</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HelloThread t1 = new HelloThread();</span><br><span class="line">        t1.setName(&quot;一号窗口&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        HelloThread t2 = new HelloThread();</span><br><span class="line">        t2.setName(&quot;二号窗口&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HelloThread extends Thread&#123;</span><br><span class="line">    private int ticket = 5;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(this.getName()+(ticket--));</span><br><span class="line">            if (ticket&lt;1) &#123;</span><br><span class="line">               break;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程的状态变化</p>
<p>创建状态：创建一个线程对象，如 Thread t = new Thread();</p>
<p>就绪状态：新建线程对象后，调用该对象的start()方法就可以启动线程。线程启动后进入就绪状态。进入线程队列排队等待CPU</p>
<p>服务。</p>
<p>运行状态：当就绪状态被调用并获得处理器资源时，线程进入运行状态。此时，自动调用该线程对象的run()方法。run()方法定义该线程的操作和功能。</p>
<p>阻塞状态：当一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让CPU暂时中止自己的执行，进入阻塞状态。在可执行状态下，如调用sleep(),wait()等方法，线程也会进入阻塞状态，发生阻塞时线程不能进入排队队列。</p>
<p>死亡状态：线程调用stop()方法或run()方法结束后，即处于死亡状态。</p>
</li>
</ul>
<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p><a href="https://blog.csdn.net/hundan_520520/article/details/54881208" target="_blank" rel="noopener">https://blog.csdn.net/hundan_520520/article/details/54881208</a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><p>使用递归算法解决斐波那契数列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Digui &#123;</span><br><span class="line">    // 0 5 5 10 15 25 。。。 求第50个数的值</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Digui digui = new Digui();</span><br><span class="line">        // System.out.println(digui.digui(50));</span><br><span class="line">        for (int i = 1; i &lt;50 ; i++) &#123;</span><br><span class="line">            System.out.println(digui.digui(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long digui(int x)&#123;</span><br><span class="line">        if(x ==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x == 2)&#123;</span><br><span class="line">            return 5;</span><br><span class="line">        &#125;</span><br><span class="line">        //第3个数的值=第一个数的值(didui(3-2))+第二个数的值（digui(3-1)）</span><br><span class="line">        return digui(x - 2) + digui(x - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><ul>
<li><p>如何设计一个秒杀系统：<a href="https://blog.csdn.net/suifeng3051/article/details/52607544" target="_blank" rel="noopener">https://blog.csdn.net/suifeng3051/article/details/52607544</a></p>
<p>并发量大、库存少，防止超卖（使用redis锁，乐观锁）；</p>
<p>做法思路：</p>
<ul>
<li><p>限制流量：</p>
<ul>
<li>产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；</li>
<li>JS 层面，限制用户在 x 秒之内只能提交一次请求；</li>
<li>站点层面：对uid进行uid进行计数和去重</li>
<li>服务层（重点）：</li>
</ul>
</li>
<li><p>削峰</p>
</li>
<li><p>异步处理</p>
</li>
<li><p>内存缓存</p>
</li>
<li><p>做法：</p>
<ol>
<li>缓存系统负责接收记录用户请求：用原子类型的变量值作为key（比如商品），用户id作为value，将数据存入列表里，每次请求判断列表的长度。</li>
<li>消息中间件(MQ)负责将缓存中的请求同步到数据库</li>
<li>执行</li>
</ol>
</li>
<li><p>分布式锁</p>
<ul>
<li>基于Redis SETNX方法（对应Java中的setIfAbsent）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li><p>常用的linux命令</p>
<p>查看tomcat进程：ps -ef | grep tomcat</p>
<p>查看网络状态（根据经常查看端口号）： sudo netstat -naop | grep 端口号</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/08/14/java/Java面试知识点/" data-id="ck2k66wa30006sncnxnv278x2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2019/08/14/java/java常用工具类/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/blog/2019/08/12/mysql/mysql/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/11/04/hexo操作/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/10/数据结构与算法/数组/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/09/数据结构与算法/时间、空间复杂度/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/09/数据结构与算法/数据结构与算法之美/">数据结构与算法之美</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/09/Shell-POST/">Shell &amp; POST</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 leonezhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>