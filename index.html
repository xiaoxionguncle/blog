<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>LeoneZhu‘s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="LeoneZhu‘s Blog">
<meta property="og:url" content="https://leonezhu.github.io/blog/index.html">
<meta property="og:site_name" content="LeoneZhu‘s Blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeoneZhu‘s Blog">
  
    <link rel="alternate" href="/blog/atom.xml" title="LeoneZhu‘s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">LeoneZhu‘s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">记录美丽生活</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://leonezhu.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hexo操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/11/04/hexo操作/" class="article-date">
  <time datetime="2019-11-04T08:25:24.462Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo文档</a></p>
<p><strong>新建一篇文章</strong></p>
<blockquote>
<p>$ hexo new [layout] <title></title></p>
</blockquote>
<p>layout = 布局，默认值为post 代表路径为source/_posts</p>
<p><strong>生成文件&amp;部署</strong></p>
<blockquote>
<p> $ hexo generate –deploy</p>
<p> $ hexo deploy –generate</p>
</blockquote>
<p>简写</p>
<blockquote>
<p>  $ hexo g -d</p>
<p>  $ hexo d -g</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/11/04/hexo操作/" data-id="ck2k66w9c0000sncnrrgrzrag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构与算法/数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/10/10/数据结构与算法/数组/" class="article-date">
  <time datetime="2019-10-10T04:10:03.587Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同数据类型的数据。</p>
<p><strong>线性表</strong></p>
<p>线性表就是数据排成 一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7szc5c5ezj30vq0n5acy.jpg" alt="img"></p>
<p> <strong>连续的内存空间与相同类型的数据</strong></p>
<p>这两个特性使数组拥有“随机访问”的特性。弊端在于类似在数组中删除、插入一个数据时，为了保证连续性，会比较低效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure>

<p>数组随机访问时通过以上公式计算目标元素存储的内存地址。date_type_size是指数组中该类型元素的大小，如int就是4字节</p>
<blockquote>
<p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存</p>
</blockquote>
<p>//TODO  Java 集合总结、与数组对比、ArrayList源码分析</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/10/10/数据结构与算法/数组/" data-id="ck2k66wa00004sncn39mv64on" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构与算法/时间、空间复杂度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/10/09/数据结构与算法/时间、空间复杂度/" class="article-date">
  <time datetime="2019-10-09T04:32:05.665Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>复杂度分析的作用</strong></p>
<p>数据结构与算法解决的是“快”和“省 ”的问题，时间 、空间复杂度就是用来衡量算法执行效率的考量指标。</p>
<p>与其对应的是“事后统计法”，即先将代码跑一遍，然后通过统计、监控得到算法 执行的时间与占用的内存来分析。</p>
<p><strong>大O复杂度表示法</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7rwzsuip5j30vh031q31.jpg" alt="img"></p>
<p>T(n)表示代码执行的时间；</p>
<p>n表示数据规模的大小；</p>
<p>f(n)表示每行代码执行的次数的总和；</p>
<p>O表示代码执行时间T(n)与f(n)表达式成正比；</p>
<p>(n) = O(2n2+2n+3) 即大O时间复杂度表示法，并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫渐进时间复杂度，即时间复杂度。空间复杂度类似。</p>
<p><strong>时间复杂度分析</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (; p &lt; 100; ++p) &#123; </span><br><span class="line">	sum = sum + p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*该段代码虽然是个循环 ，但是循环次数是已知的而不是n，所以时间复杂度依旧是常数级别的，不能代表执行效率与数据规模增长的变化 ，所以可以忽略。</p>
<p>总的时间复杂度等于量级最大的那段代码的时间复杂度。</p>
<p><strong>常见的时间复杂度实例</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7rxl8108ij30vq0fwjti.jpg" alt="img"></p>
<p>非多项式量级：O(2^n) 和 O(n!)。非多项式量级的算法问题叫做NP（非确定多项式）问题 。 非多项式：规模n不是出现在底数的位置。</p>
<p><strong>对数</strong></p>
<blockquote>
<p>如果a的x次方等于N（a&gt;0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=logaN。其中，a叫做对数的<a href="https://baike.baidu.com/item/底数/5416651" target="_blank" rel="noopener">底数</a>，N叫做<a href="https://baike.baidu.com/item/真数/326681" target="_blank" rel="noopener">真数</a>。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/10/09/数据结构与算法/时间、空间复杂度/" data-id="ck2k66wa40007sncn57ey1yxu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构与算法/数据结构与算法之美" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/10/09/数据结构与算法/数据结构与算法之美/" class="article-date">
  <time datetime="2019-10-09T04:19:23.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/10/09/数据结构与算法/数据结构与算法之美/">数据结构与算法之美</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h3><p>广义 上数据结构是指一组数据的存储结构；算法是指操作数据的一组方法；</p>
<p>狭义上就是指队列、栈、堆、二分查找、动态规划等著名的数据结构与算法；</p>
<p>两者的关系？数据结构是为算法服务的，算法要作用在特定的数据结构 上。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ru1r6jv7j30u01tau05.jpg" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/10/09/数据结构与算法/数据结构与算法之美/" data-id="ck2k66w9z0003sncngzl3a80s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Shell-POST" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/10/09/Shell-POST/" class="article-date">
  <time datetime="2019-10-09T02:20:49.000Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/10/09/Shell-POST/">Shell &amp; POST</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">-H &quot;Content-Type:application/json&quot; </span><br><span class="line">-X POST -d  &apos;&#123;&quot;image&quot;:&quot;test&quot;,&quot;id_card_side&quot;:&quot;front&quot;,&quot;detect_direction&quot;:&quot;true&quot;,&quot;detect_risk&quot;:&quot;true&quot;&#125;&apos; </span><br><span class="line">https://aip.baidubce.com/rest/2.0/ocr/v1/idcard?access_token=24.736647a5fe3f05204fa6a6cf4adf6edb.2592000.1572424892.282335-10853578</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/10/09/Shell-POST/" data-id="ck2k66w9f0001sncnws9i12at" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-高效学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/08/19/高效学习/" class="article-date">
  <time datetime="2019-08-18T17:24:39.076Z" itemprop="datePublished">2019-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="高效学习"><a href="#高效学习" class="headerlink" title="高效学习"></a>高效学习</h1><h2 id="端正学习态度"><a href="#端正学习态度" class="headerlink" title="端正学习态度"></a>端正学习态度</h2><p>学习是一件逆人性的事，就像锻炼身体一样，需要人持续付出，会让人感到痛苦，并随时想找理由放弃</p>
<ul>
<li><p>被动学习</p>
<p>听讲、阅读、试听、演示</p>
</li>
<li><p>主动学习</p>
<p>讨论、时间、教授他人</p>
<p>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。在思辨，要践行，要总结和归纳，否则，你只是在机械地重复某件事，而不会有质的成长</p>
</li>
<li><p>浅度学习</p>
<p>从微信公众号、博客等平台获取别人总结的知识。让人短时间内体会到轻松获取知识的快感，并产生勤奋好学和成长的幻觉。陷入啊“什么都懂，却依然过不好这一生“的状态 </p>
</li>
<li><p>深度学习</p>
<p>有更深层次的思考、把知识转换成自己技能</p>
</li>
<li><p>如何进行深度学习？</p>
<ul>
<li>知识采集：获取信息源头、破解表面信息的内在本质、多方数据印证</li>
<li>知识缝合：把信息组织起来，成为结构体的知识。连接记忆，逻辑推理，知识梳理</li>
<li>技能转换：举一反三、实践和练习、传授教导，把知识转化成自己的技能</li>
</ul>
</li>
<li><p>学习的观点</p>
<ul>
<li><p>学习是为了找到方法</p>
<p>学习不仅仅是为了找到答案，而是为了找到方法。只有掌握解题的思路和方法，才算得上拥有解决问题的能力</p>
</li>
<li><p>学习是为了找到真理</p>
<p>学习不仅仅是为了知道，而更是为了思考和理解。学习的过程中，我们不是为了知道某个事得表面是什么，而是要通过表象去探索其内在的本质和原理</p>
</li>
<li><p>学习是为了了解自己</p>
<p>学习不仅仅是为了开拓眼界，而更是为了找到自己的未知，为了了解自己。你不知道你不知道的东西。你永远不会去学习你不知道其存在的东西。学习可以让你知道自己不知道的东西</p>
</li>
<li><p>学习是为了改变自己</p>
<p>学习是为了改变自己的思考方式、思维方式，改变自己与生俱来的那些垃圾和低效的算法。学习让我们改变自己，行动和实践，反思和改善，从而获得成长</p>
</li>
</ul>
</li>
</ul>
<h2 id="源头、原理和知识地图"><a href="#源头、原理和知识地图" class="headerlink" title="源头、原理和知识地图"></a>源头、原理和知识地图</h2><ul>
<li>挑选知识和信息源</li>
<li>注重基础和原理</li>
<li>知识地图</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/08/19/高效学习/" data-id="ck2k66w9h0002sncnm8ghlbr0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/08/14/java/缓存/" class="article-date">
  <time datetime="2019-08-13T18:31:42.658Z" itemprop="datePublished">2019-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li><p>类型</p>
<ul>
<li>本地缓存</li>
<li>分布式缓存</li>
<li>多级缓存</li>
</ul>
</li>
<li><p>淘汰策略</p>
<ul>
<li>FIFO：先入先出，淘汰最早的数据</li>
<li>LRU：最近最少使用的数据</li>
<li>LFU：最近使用频率最低的数据</li>
</ul>
</li>
<li><p>缓存问题</p>
<ul>
<li>缓存不一致</li>
<li>缓存更新</li>
<li>缓存击穿</li>
<li>缓存雪崩</li>
</ul>
</li>
<li><p>Memcache</p>
</li>
<li><p>Redis</p>
<ul>
<li><p>Redis特点 </p>
<ul>
<li>单线程异步IO</li>
<li>支持持久化</li>
<li>多数据结构</li>
<li>主从模式</li>
</ul>
</li>
<li><p>数据结构 </p>
<ul>
<li>String</li>
<li>hash</li>
<li>set</li>
<li>list</li>
<li>zset</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>pub/sub：简单的订阅发布功能，可以用作消息队列</li>
<li>pipeline：批量执行一组执行，一次性返回所有请求结果</li>
<li>lua脚本</li>
<li>事务：不是严格的事务，只保证串行执行命令，只保证全部执行，失败不会回滚</li>
</ul>
</li>
<li><p>数据持久化 </p>
<p>​    <a href="http://redisdoc.com/topic/persistence.html" target="_blank" rel="noopener">http://redisdoc.com/topic/persistence.html</a></p>
<ul>
<li><p>RDB：在指定的时间间隔里生成数据集的时间点快照。RDB文件是简洁的单文件，适合用于做灾备。比起AOF，在数据量大的情况下，RDB的启动速度更快。保存快照时可能导致服务短时间不可用</p>
</li>
<li><p>AOF：记录服务器执行写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</p>
<p>两种方式同时启用的化，在Redis重启时会优先使用AOF文件来欢迎数据集，因为AOF文件保存的数据集通常比RDB文件保存的数据集更加完整。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>redis cluster </p>
<pre><code>[Redis集群的原理和搭建](&lt;https://juejin.im/entry/596343056fb9a06bc340ac15&gt;)</code></pre><p>​    Redis集群使用数据分片实现，一个Redis集群包含16384个哈希槽。</p>
<ul>
<li>Sentinel</li>
<li>主从同步：为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</li>
<li>master选举</li>
</ul>
</li>
<li><p>Redis数据一致性</p>
<p>Redis不能保证数据的强一致性，导致数据不一致的原因有</p>
<ul>
<li>异步复制：客户端向主节点写入一条命令，主节点向客服端回复命令状态，之后才由主节点将操作复制给子节点们</li>
<li>网络分区：客户端与其中一个主节点因网络分区分在一块，因网络分区时间较长，节点超时该主节点的子节点已经被选举为新的主节点，故原主节点写入的数据就会丢失</li>
</ul>
</li>
<li><p>key失效机制 </p>
<ul>
<li>主动删除：周期性地从设置了失效时间的主键中选择一部分失效的主键删除</li>
<li>被动删除：消极方法，在主键被访问时发现它是否失效，失效的话删除</li>
</ul>
</li>
<li><p>淘汰策略</p>
<ul>
<li><p><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
</li>
<li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p>
</li>
<li><p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
</li>
<li><p><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p>
</li>
<li><p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
</li>
<li><p><strong>no-enviction</strong>（驱逐）：禁止驱逐数据，容量满时报错不能添加数据，只能新增</p>
</li>
</ul>
</li>
<li><p>Redis大量数据插入</p>
<p>使用管道执行大批量的set key value生成的协议</p>
</li>
</ul>
<ul>
<li>缓存常见问题</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7rrv77jh7j30r10ciq85.jpg" alt="缓存常见问题"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/08/14/java/缓存/" data-id="ck2k66wa9000csncnqonqausi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/08/14/java/多线程/" class="article-date">
  <time datetime="2019-08-13T18:31:42.658Z" itemprop="datePublished">2019-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><p>ArrayBlockingQueue类</p>
<p>是java.util.concurrent包下的一个基于数组的阻塞队列。主要方法有：</p>
<p>add(E e)：将e加到队列里，实际调用offer方法，失败报错</p>
<p>offer(E e)：将e放到队列里，如果队列可以容纳，则返回ture，否则返回false</p>
<p>offer(E e, long timeout, TimeUnit unit)：添加超时时间参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">  </span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length) &#123;</span><br><span class="line">        //超时，直接返回false</span><br><span class="line">            if (nanos &lt;= 0L)</span><br><span class="line">                return false;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put(E e)：将e放到队列里，如果队列没有空间，则调用该方法的线程被阻断，直到队列里有空间再继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>Sleep()与wait()的区别？</p>
<ol>
<li>sleep是Treed类的方法，wait是Object类的方法</li>
<li>sleep不会影响锁行为的改变</li>
<li>sleep与wait都会暂停当前的线程，调用wait后需要别的线程执行notify/notifyAll才能重新获得CPU的执行时间</li>
<li></li>
</ol>
</li>
<li><p>锁</p>
<p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">Java锁</a></p>
<ul>
<li><p>Synchronized 与 Lock的区别</p>
<p><a href="https://blog.csdn.net/u012403290/article/details/64910926" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/64910926</a></p>
<ol>
<li>Synchronized 是Java中的关键字，托管给JVM执行。Lock是接口，通过java代码控制锁的实现，常用的类有ReentrantLock。</li>
<li>Synchronized 锁的释放方式有两种。一是获取锁的线程执行完了同步代码，释放锁。二是执行异常释放锁。Lock获取锁后必须再finaly里释放锁，不然会死锁</li>
<li>两者锁的获取方式不一样。对于Synchronized 而言，假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待。Lock有很多实现类，获取锁的方式也有多种。。。TODO</li>
<li>Synchronized 无法获得锁的状态，Lock可以判断</li>
<li>可实现的锁类型不一样：Synchronized（可重入 不可中断 非公平） ，Lock（可重入 可判断 可公平（两者皆可））</li>
</ol>
</li>
<li><p>锁的类型</p>
<ul>
<li><p>可重入锁：在执行对象中所有同步方法不用再次获得锁</p>
</li>
<li><p>可中断锁：在等待获取锁过程中可中断</p>
</li>
<li><p>公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利</p>
</li>
<li><p>读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写</p>
</li>
<li><p>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁</p>
</li>
<li><p>乐观锁：认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>volatile深入分析</p>
<p><a href="https://blog.csdn.net/vernonzheng/article/details/8201744" target="_blank" rel="noopener">https://blog.csdn.net/vernonzheng/article/details/8201744</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/08/14/java/多线程/" data-id="ck2k66wa7000asncnvfbx5v10" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/java常用工具类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/08/14/java/java常用工具类/" class="article-date">
  <time datetime="2019-08-13T18:31:42.657Z" itemprop="datePublished">2019-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java常用工具类"><a href="#Java常用工具类" class="headerlink" title="Java常用工具类"></a>Java常用工具类</h1><ul>
<li><p>CountDownLatch</p>
<p>CountDodnLatch是一个常用的多线程控制工具类，是一个倒计时器。通过int参数的构造方法初始化一个指定线程数量的对象。主要方法有countDown(),awit()。</p>
<p>countDown()：通知CountDownLatch有一个线程已经准备完毕，倒计数器减一</p>
<p>awit()：要求主线程等待所有线程检查任务全部准备好才一起并行执行</p>
<p>参考文档：<a href="https://www.relaxheart.cn/to/blog/streamline?uuid=83" target="_blank" rel="noopener">https://www.relaxheart.cn/to/blog/streamline?uuid=83</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/08/14/java/java常用工具类/" data-id="ck2k66wa8000bsncns610dtso" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/Java面试知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/08/14/java/Java面试知识点/" class="article-date">
  <time datetime="2019-08-13T18:31:42.657Z" itemprop="datePublished">2019-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li><p>在Java中String类为什么要设计成finnal？</p>
<p>​    <a href="https://blog.csdn.net/u013905744/article/details/52414111" target="_blank" rel="noopener">https://blog.csdn.net/u013905744/article/details/52414111</a></p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>什么是多线程？与单线程的区别？有什么好处？</p>
<p>答题思路：先描述什么进程？什么是线程？什么是多线程？然后再描述多线程的优缺点。最后结合实际使用</p>
<p>答：进程是程序的一次动态执行过程。线程是比进程更小的执行单位，执行流。多线程就是值程序中包含多个执行流，就是说一个程序中可以同时运行多个线程来并向执行不同的任务。</p>
<p>多线程的好处：可以提高CPU利用率，在多线程程序中，一个线程必须等待的时候（逻辑处理，耗时）。CPU可以运行其他的线程而不是等待，这样提高了效率，也就是程序运行速度。</p>
<p>多线程的不利：</p>
<ul>
<li>线程也是程序，需要占用内存，线程越多占用内存也越多。</li>
<li>多线程需要协调和管理，所以需要CPU时间跟踪线程； </li>
<li>线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题；</li>
<li>线程太多会导致控制太复杂，最终可能造成很多Bug；</li>
</ul>
<p>比如获取商品详情页数据的接口时，需要返回商品的图片信息、规格、相似商品等，这里就用了CountDownLatch这个多线程计数器来实现多线程</p>
</li>
<li><p>Thead.start()实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">       /**</span><br><span class="line">        * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="line">        * group threads created/set up by the VM. Any new functionality added</span><br><span class="line">        * to this method in the future may have to also be added to the VM.</span><br><span class="line">        *</span><br><span class="line">        * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="line">        */</span><br><span class="line">        //1 判断线程状态，是否</span><br><span class="line">       if (threadStatus != 0)</span><br><span class="line">           throw new IllegalThreadStateException();</span><br><span class="line">  </span><br><span class="line">       /* Notify the group that this thread is about to be started</span><br><span class="line">        * so that it can be added to the group&apos;s list of threads</span><br><span class="line">        * and the group&apos;s unstarted count can be decremented. */</span><br><span class="line">       group.add(this);</span><br><span class="line">  </span><br><span class="line">       boolean started = false;</span><br><span class="line">       try &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = true;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(this);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Throwable ignore) &#123;</span><br><span class="line">               /* do nothing. If start0 threw a Throwable then</span><br><span class="line">                 it will be passed up the call stack */</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://juejin.im/post/5b09274af265da0de25759d5" target="_blank" rel="noopener">https://juejin.im/post/5b09274af265da0de25759d5</a></p>
</li>
<li><p>Java中线程的实现方式</p>
<p>1.实现Runnable。2继承Thread类。Thread类也是Runnable的子类，但是Thread类并没有完全实现Runnable接口中的run()方法，Thread类中的run()方法调用的是Runnable接口中的run()方法，也就是说该方法是由Runnable子类完成的，所以要通过继承Thread类实现多线程，则必须覆写run()方法。</p>
<p><strong>两种方式的区别是实现Runnable接口可以避免单继承的局限性，二是可以实现资源的共享</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HelloThread t1 = new HelloThread();</span><br><span class="line">        t1.setName(&quot;一号窗口&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        HelloThread t2 = new HelloThread();</span><br><span class="line">        t2.setName(&quot;二号窗口&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class HelloThread extends Thread&#123;</span><br><span class="line">    private int ticket = 5;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(this.getName()+(ticket--));</span><br><span class="line">            if (ticket&lt;1) &#123;</span><br><span class="line">               break;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程的状态变化</p>
<p>创建状态：创建一个线程对象，如 Thread t = new Thread();</p>
<p>就绪状态：新建线程对象后，调用该对象的start()方法就可以启动线程。线程启动后进入就绪状态。进入线程队列排队等待CPU</p>
<p>服务。</p>
<p>运行状态：当就绪状态被调用并获得处理器资源时，线程进入运行状态。此时，自动调用该线程对象的run()方法。run()方法定义该线程的操作和功能。</p>
<p>阻塞状态：当一个正在执行的线程在某些特殊情况下，如被人为挂起或需要执行耗时的输入/输出操作，会让CPU暂时中止自己的执行，进入阻塞状态。在可执行状态下，如调用sleep(),wait()等方法，线程也会进入阻塞状态，发生阻塞时线程不能进入排队队列。</p>
<p>死亡状态：线程调用stop()方法或run()方法结束后，即处于死亡状态。</p>
</li>
</ul>
<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p><a href="https://blog.csdn.net/hundan_520520/article/details/54881208" target="_blank" rel="noopener">https://blog.csdn.net/hundan_520520/article/details/54881208</a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><p>使用递归算法解决斐波那契数列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Digui &#123;</span><br><span class="line">    // 0 5 5 10 15 25 。。。 求第50个数的值</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Digui digui = new Digui();</span><br><span class="line">        // System.out.println(digui.digui(50));</span><br><span class="line">        for (int i = 1; i &lt;50 ; i++) &#123;</span><br><span class="line">            System.out.println(digui.digui(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long digui(int x)&#123;</span><br><span class="line">        if(x ==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x == 2)&#123;</span><br><span class="line">            return 5;</span><br><span class="line">        &#125;</span><br><span class="line">        //第3个数的值=第一个数的值(didui(3-2))+第二个数的值（digui(3-1)）</span><br><span class="line">        return digui(x - 2) + digui(x - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><ul>
<li><p>如何设计一个秒杀系统：<a href="https://blog.csdn.net/suifeng3051/article/details/52607544" target="_blank" rel="noopener">https://blog.csdn.net/suifeng3051/article/details/52607544</a></p>
<p>并发量大、库存少，防止超卖（使用redis锁，乐观锁）；</p>
<p>做法思路：</p>
<ul>
<li><p>限制流量：</p>
<ul>
<li>产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；</li>
<li>JS 层面，限制用户在 x 秒之内只能提交一次请求；</li>
<li>站点层面：对uid进行uid进行计数和去重</li>
<li>服务层（重点）：</li>
</ul>
</li>
<li><p>削峰</p>
</li>
<li><p>异步处理</p>
</li>
<li><p>内存缓存</p>
</li>
<li><p>做法：</p>
<ol>
<li>缓存系统负责接收记录用户请求：用原子类型的变量值作为key（比如商品），用户id作为value，将数据存入列表里，每次请求判断列表的长度。</li>
<li>消息中间件(MQ)负责将缓存中的请求同步到数据库</li>
<li>执行</li>
</ol>
</li>
<li><p>分布式锁</p>
<ul>
<li>基于Redis SETNX方法（对应Java中的setIfAbsent）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><ul>
<li><p>常用的linux命令</p>
<p>查看tomcat进程：ps -ef | grep tomcat</p>
<p>查看网络状态（根据经常查看端口号）： sudo netstat -naop | grep 端口号</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leonezhu.github.io/blog/2019/08/14/java/Java面试知识点/" data-id="ck2k66wa30006sncnxnv278x2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/算法/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/算法/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019/11/04/hexo操作/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/10/数据结构与算法/数组/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/09/数据结构与算法/时间、空间复杂度/">(no title)</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/09/数据结构与算法/数据结构与算法之美/">数据结构与算法之美</a>
          </li>
        
          <li>
            <a href="/blog/2019/10/09/Shell-POST/">Shell &amp; POST</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 leonezhu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>